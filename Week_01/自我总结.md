##### 第一周 自我总结

这周主要学习的内容有：

- 数组 
- 链表
- 跳表 
- 栈 
- 队列 

这五中数据结构，期中，队列中又学习了 
- 队列 
  - 优先队列
  - 双端队列


期中：

- 数组 适合查找操作，特别适合使用下标进行查找：大致原因如下：数组的特点是分配一块连续的内存空间，在内存寻址上，只需要记住首地址即可，然后通过下标便宜，进行访问，这就成就了数组的下标访问元素的时间复杂度是 O(1),二插入删除操作则需要移动元素，所以时间复杂度是 O(n)
  
- 链表 在内存分配上是不需要连续的空间，但是需要额外的一个空间来指向下一个节点的位置，这个空间成为 next指针，链表在插入删除操作上只需要调整前节点和当前节点就好，所以时间复杂度是 O(1)，而查找的，则需要遍历整个链表，所以时间复杂度是 O(n)，以上所述的链表是单链表，只有一个next指针，如果在添加一个prev指针的话，就变成了一个双向链表.
- 双向链表的插入删除操作的时间复杂度是 O(1),查找操作是单链表的一半的时间复杂度度 O(n)/2 也是记做 O(n),双向链表是典型的空间换时间的思想。使用多一个的 prev指针，来换取一半的查询时间。当然 跳表也是这种空间换时间的思想。

- 跳表的前驱条件是有序的单链表，在单链表上，每隔一定的节点数，抽出一层来当做索引, 然后在查找时，先通过索引层定位到某一段上，然后在该段上进行查询，时间复杂度是 O(logn),空间复杂度是 O(n)

- 栈是一种先进后出的数据结构 FILO， 可以用数组来实现，也是用链表来实现
- 栈是一种先进先出的数据结构 FIFO， 可以用数组来实现，也是用链表来实现

##### 结合实际开发的感想

- 数组可能是目前用的最多的一种数据结构，在开发过程中，使用的频率非常高，所以，对一些数组的api的时间复杂度需要有明确的认识：

- 链表常在一些缓存的三方库里面，比如说 YYCache就是使用的双向链表，同时还是用了 Hash表来存储一份数据，来把对象的查找时间复杂度降低成 O(1)

- 栈的话，常说的方法调就是使用这个数据结构，在方法调用完之后，栈上面申请的内存和临时变量，就会被推出栈，直接进行释放，而在堆上的内存则遵循内存管理

- 队列 在工程中用的也是非常多。


![m1](../Week_01/时间复杂度.png)